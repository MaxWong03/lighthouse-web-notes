# Lecture Notes

## TCP (Transport Control Protocol)
* Allows a computer to establish a long running connection with another computer
* We used the net module to establish a TCP connection with the server (connect to the snake game server)
* We also used the net module to create a TCP connection between the server and clients for File Server
* TCP is a long running connection, with connections are always started by the Client
* Connection can end by:
  - Server decision to terminate
  - Client decision to terminate
  - Network disruption 
* **Both sides can send data to each other of any kind, any time**
* Its up to you to decide whether or not if they should talk over each other (send data to each other at the same time)
* **Analogy**: allows long running internet `calls` between two machiens / devices

## HTTP Hyper-Text Transport Protocol
* Uses TCP to allow text (UTF8) based communnication between computers
* `Request-Response` based protocol
* Using older version of HTTP, client and server **Can't** talk over each other (send data to each other at the same time)
* After request and response, the client continues to request the next response
* Based on being able to fetch/submit new resources (documents)
* Rules / language of how to speak to each other (in the snake game, we use the snake protocol)
  - client speaks "Move: up"
  - server speaks with moving the snake
* 2 things make up a request 
  1) Method
  2) Path

## Express Server
* `response.send` will `close` the `connection`
* `response.write` allows you to call `write multiple times`

## EJS
* `ejs` helps you `make` the `html` file into a `string` in which you can `send` `back` to the `client` as a `response`
  - Instead of putting the entire html file as a string in your JS, you could have that file somewhere else and just let ejs render it into a string and send back to the client as a response
  - You dont have to restart your server if you make change to the ejs template because the templates get loaded when it is requested by the clients
* `response.render` allows you to pass in dynamic data in the ejs template you want to render, and you do this by doing `response.render(index, {name: KV})` **(file, data)**
* In the ejs template you want to render, you get the dynamic data by `<%= dynamicData%> (Injecting data)
  - In ejs, if you want to write JS, you have to start with <% JS code %>
* `/path/:name` get you a dynamic url, in which you can access the value of `:name` by `request.params` (this is useful if you have a database of info you want to retrieve)
  - doing routing this way, `/path` is no longer a `valid path`, it has to be `/path/string` when a client is sending a request
  - and the object you get back by doing `request.params` will have the `:name` (string) as the key 
  - so if you have `/path/dragon` the object returned will be `{name: dragon}`
  - so I believe you can rename `:name` with other name you like
* `request.query` gives you an `object` `containing` all the `key value pair` after `/path?`


# Writing Server
* When you write a server, you `have to make sure` for `paths` that you `dont want` user to `access` you change the `response status code to 404` because by `default every response status code is 200`
* What you write back to the client is the `body` of the response message
* Curl -i includes the `header` of the response message
* `404` is for an `unknown path`, the `400-series` HTTP status codes are `Client Errors`, there are also `401 and 403`
* The browsers `DevTools` (network tab) let you know if the HTTP response code is 404
* You also have to make sure you `end the request` from the client 
* **For a given request, only one of the callback handler is called**
* In path, anything after `/path?` contains many `key value pair` that we can access
  - In Express Server, you can access the `key value pair` by doing `request.query`