# Client Side JavaScript
* `HTML` expresses the `structure` of the `DOM`, it adds `context` to the `content` of the `page`
* `CSS` deals with element styling, positioning, and basic animation. It `determines` the `appearance` of the content
* `Javascript` defines the `beahviour` of the content, it handles the `behaviour`, `logic`, and `dyanmic content`

# JS vs the DOM
* JS is a language that the **browser reads and does stuff with **, and the` DOM is where the stuff happens`

# Chrome Developer Tools
* `Breakpoint` allows us to `pause` execution on a `given line` of our program while `maintaining` the programming `state`
* `State` includes `values` of all the `variables` and the `call stack`

# DOM Events
``` js
element.addEventListener(<event-name>, <callback>, <use-capture>);
```
* the `use-capture` part declares whether the callback should be fired in the `capture` phase
* `Removing` event `listeners` once they are `no longer needed` is a `best practice` (using the `element.removeEventListener())
  - **but you must have a reference to the callback function that was originally bound**
* In the case of `nested elements`, `mouse` and `pointer` events are `always` **targeted at the most deeply nested element**

## stopPropagation vs stopImmediatePropagation vs preventDefault
* `stopPropagation` prevents `propagation` (bubbling), but it `doesnt` `stop` `additional event listeners` from being called on the current target
* `stopImmediatePropagation` `stops all listener` on the current target
* `preventDefault` `prevent` the `browser` from `doing` its `default` things

## Incorrect call back context example
``` js
var element = document.getElementById('element');

var user = {
 firstname: 'Wilson',
 greeting: function(){
   alert('My name is ' + this.firstname);
 }
};

// Attach user.greeting as a callback
element.addEventListener('click', user.greeting);

// alert => 'My name is undefined'
```
* When we pass the `greeting` function to the `addEventListener` method, we are only passing a `reference` to the `function
* the `context` of `usr` is not `passed` with it
* Interally, the `callback` is `called in the context of element`, which means that `this` refers to `element`, not to user
* Therefore, `this.firstname` is undefined

# Custom DOM Events
**The following is an example of making a custom DOM event**
``` js
var myEvent = new CustomEvent("myevent", {
  detail: {
    name: "Wilson"
  },
  bubbles: true,
  cancelable: false
});

// Listen for 'myevent' on an element
myElement.addEventListener('myevent', function(event) {
  alert('Hello ' + event.detail.name);
});

// Trigger the 'myevent'
myElement.dispatchEvent(myEvent);
```

# Event Delegation
* inspect `event.target` to identify which `deleagtee element` triggers the event

## Event Delegation in jQuery
``` js
// Not using event delegation
$('li').on('click', function(){});

// Using event delegation
$('ul').on('click', 'li', function(){});
```

### Useful Events
1) LOAD - (fires on any resource that has finished loading)
2) ONBEFOREUNLOAD - ask the user to confirm that they want to leave the page (save changes before closing browser)
3) RESIZE - for responsive layouts
4) TRANSITIONED
5) ANIMATIONITERATION
6) ERROR